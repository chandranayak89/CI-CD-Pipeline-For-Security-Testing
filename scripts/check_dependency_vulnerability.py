#!/usr/bin/env python3
"""
Check Dependency Vulnerability

This script checks Python dependencies for known security vulnerabilities using
the Safety package. It's designed to be used as a pre-commit hook to prevent
adding vulnerable dependencies to requirements.txt.
"""

import os
import re
import sys
import json
import subprocess
import tempfile
from typing import List, Dict, Any, Tuple, Set


def parse_requirements(file_path: str) -> Set[str]:
    """
    Parse requirements file and extract package names and versions
    
    Args:
        file_path: Path to requirements.txt file
        
    Returns:
        Set of package specifications (name==version)
    """
    packages = set()
    
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            
            # Skip comments and empty lines
            if not line or line.startswith('#'):
                continue
            
            # Remove inline comments
            if '#' in line:
                line = line.split('#')[0].strip()
            
            # Skip non-package lines (like -r other-requirements.txt)
            if line.startswith('-'):
                continue
            
            # Extract package name and version
            if '==' in line:
                packages.add(line)
            elif '>=' in line or '>' in line or '<=' in line or '<' in line:
                # For version ranges, we'll need to find a specific version
                # For simplicity, we'll just add the package name
                package_name = re.split('[<>=]', line)[0].strip()
                packages.add(package_name)
            else:
                # No version specified, just add the package name
                packages.add(line)
    
    return packages


def check_dependencies(dependencies: Set[str]) -> List[Dict[str, Any]]:
    """
    Check dependencies for vulnerabilities using Safety
    
    Args:
        dependencies: Set of package specifications
        
    Returns:
        List of vulnerabilities found
    """
    if not dependencies:
        return []
    
    # Create a temporary requirements file
    with tempfile.NamedTemporaryFile('w', suffix='.txt', delete=False) as tmp:
        for dep in dependencies:
            tmp.write(f"{dep}\n")
        tmp_path = tmp.name
    
    try:
        # Run safety check
        cmd = ['safety', 'check', '--json', '-r', tmp_path]
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        # Safety returns exit code 0 when no vulnerabilities are found
        # and non-zero when vulnerabilities are found
        if result.returncode == 0:
            return []
        
        try:
            # Parse JSON output
            vulnerabilities = json.loads(result.stdout)
            return vulnerabilities
        except json.JSONDecodeError:
            print("WARNING: Could not parse Safety output as JSON.")
            print(f"Safety output: {result.stdout}")
            return []
    except subprocess.CalledProcessError as e:
        print(f"ERROR: Safety check failed: {str(e)}")
        print(f"Output: {e.output}")
        return []
    except FileNotFoundError:
        print("WARNING: Safety is not installed. Run 'pip install safety' to enable vulnerability checking.")
        return []
    finally:
        # Clean up temporary file
        if os.path.exists(tmp_path):
            os.remove(tmp_path)


def format_vulnerability_output(vulnerabilities: List[Dict[str, Any]]) -> str:
    """
    Format vulnerability information for output
    
    Args:
        vulnerabilities: List of vulnerability dictionaries
        
    Returns:
        Formatted output string
    """
    if not vulnerabilities:
        return "No vulnerabilities found in dependencies!"
    
    output = "\nVulnerable dependencies found:\n"
    output += "="*60 + "\n"
    
    for i, vuln in enumerate(vulnerabilities, 1):
        package_name = vuln.get('package_name', 'Unknown')
        affected_version = vuln.get('vulnerable_spec', 'Unknown')
        vulnerability_id = vuln.get('vulnerability_id', 'Unknown')
        severity = vuln.get('severity', 'Unknown')
        
        output += f"{i}. {package_name} ({affected_version})\n"
        output += f"   ID: {vulnerability_id}\n"
        output += f"   Severity: {severity}\n"
        
        if 'description' in vuln:
            description = vuln['description'].replace('\n', '\n   ')
            output += f"   Description: {description}\n"
        
        if 'recommendation' in vuln:
            output += f"   Recommendation: {vuln['recommendation']}\n"
        
        output += "\n"
    
    output += "="*60 + "\n"
    output += "Fix these vulnerabilities before committing requirements.txt.\n"
    output += "Consider using 'python scripts/update_dependencies.py' to find secure versions.\n"
    
    return output


def main():
    """Main function"""
    # Default requirements file
    requirements_file = 'requirements.txt'
    
    # Check if the file exists
    if not os.path.exists(requirements_file):
        print(f"WARNING: {requirements_file} not found.")
        return 0
    
    # Parse requirements
    dependencies = parse_requirements(requirements_file)
    
    # Check for vulnerabilities
    vulnerabilities = check_dependencies(dependencies)
    
    # Output results
    output = format_vulnerability_output(vulnerabilities)
    print(output)
    
    # Return exit code
    return 1 if vulnerabilities else 0


if __name__ == "__main__":
    sys.exit(main()) 